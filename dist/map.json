{"version":3,"file":"generated.js","sources":["node_modules/browserify/node_modules/insert-module-globals/node_modules/process/browser.js","src/access.js","src/build.js","src/deferred.js","src/define.js","src/environment.js","src/errors.js","src/inits.js","src/injector.js","src/special.js","src/tunnel.js","src/type.js","src/util.js"],"names":[],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5ZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9jBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvpBA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n    && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            if (ev.source === window && ev.data === 'process-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('process-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n}\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\n","module.exports = {\n    PUBLIC: \"public\",\n    PRIVATE: \"private\",\n    PROTECTED: \"protected\"\n};\n","var access = require( \"./access\" );\nvar environment = require( \"./environment\" );\nvar errors = require( \"./errors\" );\nvar inits = require( \"./inits\" );\nvar special = require( \"./special\" );\nvar tunnel = require( \"./tunnel\" );\nvar util = require( \"./util\" );\n\nmodule.exports = init;\n\n/**\n * @private\n * @description Initializes the type.\n * @param {Type} type The type to initialize.\n * @param {Object} pub The public interface to initialize on.\n * @param {Array} args Arguments for the constructor.\n * @param {boolean} ctor Run the constructor.\n */\nfunction init( type, pub, args, ctor )\n{\n    inits.on( inits.SCOPE );\n    var scope = type();\n    inits.off( inits.SCOPE );\n\n    scope.self._pub = pub;\n\n    build( type, scope );\n    expose( type, scope, pub );\n\n    pub.$type = type;\n\n    /**\n     * @internal\n     * Use in conjunction with _pry to expose the private scope.\n     */\n    pub.$scope = function()\n    {\n        if ( tunnel.value() === type )\n            return scope.self;\n    };\n\n    if ( ctor )\n        scope.self.ctor.apply( scope.self, args );\n\n    return scope.self;\n}\n\n/**\n * @private\n * @description Creates the type members on the instance.\n * @param {Type} type The instance type.\n * @param {Scope} scope The private scope of the instance.\n */\nfunction build( type, scope )\n{\n    // Instantiate mixins and add proxies to their members.\n    util.each( type.mixins, function( mixin )\n    {\n        init( mixin, scope.self._pub, [], false );\n        tunnel.open( mixin );\n        var inner = scope.self._pub.$scope();\n        tunnel.close();\n        createProxy( mixin, inner, type, scope.self );\n        scope.mixins.push( inner );\n    });\n\n    // Instantiate the parent.\n    if ( type.parent !== null )\n    {\n        if (\n            type.parent.members.ctor &&\n            type.parent.members.ctor.params.length > 0 &&\n            ( !type.members.ctor || !type.members.ctor.callsuper )\n        )\n            throw new errors.InitializationError( \"Base constructor contains parameters and must be called explicitly.\" );\n\n        inits.on( inits.SCOPE );\n        scope.parent = type.parent();\n        inits.off( inits.SCOPE );\n        scope.parent.self._pub = scope.self._pub;\n        build( type.parent, scope.parent );\n    }\n\n    // Add proxies to parent members.\n    if ( type.parent !== null )\n        createProxy( type.parent, scope.parent.self, type, scope.self );\n\n    // Add type members.\n    util.each( type.members, function( member, name )\n    {\n        if ( member.method )\n            buildMethod( type, scope, name, member );\n        else if ( member.isEvent )\n            buildEvent( type, scope, name );\n        else\n            buildProperty( type, scope, name, member );\n    });\n\n    // If a constructor isn't defined, provide a default one.\n    if ( !scope.self.ctor )\n    {\n        buildMethod( type, scope, special.CTOR,\n        {\n            callsuper: false,\n            params: [],\n            access: access.PRIVATE,\n            isVirtual: false,\n            name: special.CTOR,\n            method: function() {}\n        });\n    }\n}\n\nfunction createProxy( srcType, srcObj, dstType, dstObj )\n{\n    util.each( srcType.members, function( member, name )\n    {\n        // If the member is private or if it's been overridden by the child, don't make a reference\n        // to the parent implementation.\n        if ( member.access === access.PRIVATE || dstType.members[ name ] ) return;\n\n        if ( member.method || member.isEvent )\n            dstObj[ name ] = srcObj[ name ];\n        else\n        {\n            addProperty( dstObj, name,\n            {\n                get: !member.get || member.get.access === access.PRIVATE ? readOnlyGet( name ) : function() {\n                    return srcObj[ name ];\n                },\n                set: !member.set || member.set.access === access.PRIVATE ? writeOnlySet( name ) : function( value ) {\n                    srcObj[ name ] = value;\n                }\n            });\n        }\n    });\n}\n\n/**\n * @private\n * @description Creates a method member.\n * @param {Type} type\n * @param {Scope} scope\n * @param {string} name\n * @param {Object} member\n */\nfunction buildMethod( type, scope, name, member )\n{\n    if ( name === \"ctor\" )\n    {\n        scope.self.ctor = function()\n        {\n            // Hide the constructor because it should never be called again.\n            delete scope.self.ctor;\n\n            // Run each mixin's constructor. If the constructor contains parameters, add it to the queue.\n            var queue = [];\n            var temp = {\n                _init: scope.self._init,\n                _super: scope.self._super\n            };\n\n            util.each( type.mixins, function( mixin, i )\n            {\n                if ( mixin.members.ctor )\n                {\n                    if ( mixin.members.ctor.params.length > 0 )\n                        queue.push( mixin );\n                    else\n                        mixin.members.ctor.method.call( scope.mixins[ i ] );\n                }\n            });\n\n            // If mixins need to be initialized explicitly, create an _init() method.\n            if ( queue.length > 0 )\n            {\n                scope.self._init = function( mixin )\n                {\n                    // Make sure we're initializing a valid mixin.\n                    var i = util.indexOf( queue, mixin );\n                    if ( i === -1 )\n                        throw new errors.InitializationError( \"Mixin is not defined for this type or has already been initialized.\" );\n\n                    var args = util.makeArray( arguments );\n                    args.shift();\n                    mixin.members.ctor.method.apply( scope.mixins[ util.indexOf( type.mixins, mixin ) ], args );\n\n                    // Remove mixin from the queue.\n                    queue.splice( i, 1 );\n                };\n            }\n\n            // Call the parent constructor if it is parameterless. Otherwise, assign it to this._super.\n            if ( type.parent !== null && type.parent.members.ctor )\n            {\n                if ( type.parent.members.ctor.params.length > 0 )\n                    scope.self._super = scope.parent.self.ctor;\n                else\n                    scope.parent.self.ctor();\n            }\n\n            member.method.apply( scope.self, arguments );\n            scope.self._super = temp._super;\n            scope.self._init = temp._init;\n\n            if ( queue.length > 0 )\n            {\n                throw new errors.InitializationError( \"Some mixins were not initialized. Please make sure the constructor \" +\n                    \"calls this._init() for each mixin having parameters in its constructor.\" );\n            }\n        };\n    }\n    else\n    {\n        if (\n            scope.parent !== null &&\n            scope.parent.self[ name ] &&\n            member.callsuper\n        )\n        {\n            var _super = scope.parent.self[ name ];\n            scope.self[ name ] = function()\n            {\n                var temp = scope.self._super;\n                scope.self._super = _super;\n                var result = member.method.apply( scope.self, arguments );\n                scope.self._super = temp;\n                return result;\n            };\n        }\n        else\n        {\n            scope.self[ name ] = function() {\n                return member.method.apply( scope.self, arguments );\n            };\n        }\n    }\n}\n\n/**\n * @private\n * @description Creates a property member.\n * @param {Type} type\n * @param {Scope} scope\n * @param {string} name\n * @param {Object} member\n */\nfunction buildProperty( type, scope, name, member )\n{\n    function accessor( method, _super )\n    {\n        return function()\n        {\n            var temp = {\n                _super: scope.self._super,\n                _value: scope.self._value\n            };\n            scope.self._super = _super;\n            scope.self._value = function( value )\n            {\n                if ( arguments.length )\n                    _value = value;\n                return _value;\n            };\n            var result = method.apply( scope.self, arguments );\n            scope.self._super = temp._super;\n            scope.self._value = temp._value;\n            return result;\n        };\n    }\n\n    var _value = member.value;\n    var accessors = {};\n    if ( member.get )\n    {\n        accessors.get = accessor(\n            member.get.method,\n            !member.get.callsuper || scope.parent === null ? null : function( value ) {\n                return scope.parent.self[ name ];\n            }\n        );\n    }\n    else\n    {\n        accessors.get = readOnlyGet( name );\n    }\n    if ( member.set )\n    {\n        accessors.set = accessor(\n            member.set.method,\n            !member.set.callsuper || scope.parent === null ? null : function( value ) {\n                scope.parent.self[ name ] = value;\n            }\n        );\n    }\n    else\n    {\n        accessors.set = writeOnlySet( name );\n    }\n    addProperty( scope.self, name, accessors );\n}\n\nfunction buildEvent( type, scope, name )\n{\n    var handlers = [];\n    scope.self[ name ] =\n    {\n        addHandler: function( handler )\n        {\n            handlers.push( handler );\n        },\n\n        removeHandler: function( handler )\n        {\n            var i = util.indexOf( handlers, handler );\n            if ( i > -1 )\n                handlers.splice( i, 1 );\n        },\n\n        raise: function()\n        {\n            var i = 0, len = handlers.length;\n            for ( ; i < len; i++ )\n                handlers[ i ].apply( scope.self._pub, arguments );\n        }\n    };\n}\n\n/**\n * @private\n * @description Creates references to the public members of the type on the public interface.\n * @param {Type} type The type being instantiated.\n * @param {Scope} scope The type instance.\n * @param {Object} pub The public interface.\n */\nfunction expose( type, scope, pub )\n{\n    if ( type.parent !== null )\n        expose( type.parent, scope.parent, pub );\n\n    util.each( type.members, function( member, name )\n    {\n        if ( member.access !== access.PUBLIC )\n            return;\n\n        if ( member.method )\n        {\n            pub[ name ] = scope.self[ name ];\n        }\n        else if ( member.isEvent )\n        {\n            pub[ name ] =\n            {\n                addHandler: scope.self[ name ].addHandler,\n                removeHandler: scope.self[ name ].removeHandler\n            };\n        }\n        else\n        {\n            addProperty( pub, name,\n            {\n                get: !member.get || member.get.access !== access.PUBLIC ? readOnlyGet( name ) : function() {\n                    return scope.self[ name ];\n                },\n                set: !member.set || member.set.access !== access.PUBLIC ? writeOnlySet( name ) : function( value ) {\n                    scope.self[ name ] = value;\n                }\n            });\n        }\n    });\n}\n\n/**\n * @private\n * @description\n * Adds a property to an object.\n * http://johndyer.name/native-browser-get-set-properties-in-javascript/\n * @param {Object} obj\n * @param {string} name\n * @param {Object} accessors\n */\nfunction addProperty( obj, name, accessors )\n{\n    // IE8 apparently doesn't support this configuration option.\n    if ( !environment.IE8 )\n        accessors.enumerable = true;\n\n    accessors.configurable = true;\n\n    // IE8 requires that we delete the property first before reconfiguring it.\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty\n    if ( environment.IE8 && util.hasOwn( obj, name ) )\n        delete obj[ name ];\n\n    // obj must be a DOM object in IE8\n    if ( Object.defineProperty )\n        Object.defineProperty( obj, name, accessors );\n    else\n        throw new errors.InitializationError( \"JavaScript properties are not supported by this browser.\" );\n}\n\nfunction readOnlyGet( name ) {\n    return function() {\n        throw new errors.AccessViolationError( \"Cannot read from write only property '\" + name + \"'.\" );\n    };\n}\n\nfunction writeOnlySet( name ) {\n    return function() {\n        throw new errors.AccessViolationError( \"Cannot assign to read only property '\" + name + \"'.\" );\n    };\n}\n","var process=require(\"__browserify_process\");var errors = require( \"./errors\" );\nvar type = require( \"./define\" );\nvar util = require( \"./util\" );\n\nvar Deferred = require( \"./deferred\" );\n\n// 2.1\nvar PENDING = \"pending\";\nvar FULFILLED = \"fulfilled\";\nvar REJECTED = \"rejected\";\n\n/**\n * @description Satisfies 2.3 of the Promise/A+ spec.\n * @param {Promise} promise\n * @param {*} x\n * @return {boolean}\n */\nfunction resolve( promise, x )\n{\n    // 2.3.1\n    if ( x === promise._pub )\n    {\n        promise.set( REJECTED, new TypeError( \"2.3.1 A promise returned from onFulfilled cannot refer to itself.\" ) );\n        return true;\n    }\n    // 2.3.3\n    if ( x )\n    {\n        var then, called = false;\n        try\n        {\n            // 2.3.3.1\n            if ( util.hasOwn( x, \"then\" ) )\n                then = x.then;\n        }\n        catch ( e )\n        {\n            // 2.3.3.2\n            promise.set( REJECTED, e );\n            return true;\n        }\n        // 2.3.3.3\n        if ( util.isFunc( then ) )\n        {\n            try\n            {\n                then.call( x,\n                    // 2.3.3.3.1\n                    function( y )\n                    {\n                        // 2.3.3.3.3\n                        if ( !called )\n                        {\n                            called = true;\n                            if ( !resolve( promise, y ) )\n                            {\n                                // 2.3.4\n                                promise.set( FULFILLED, y );\n                            }\n                        }\n                    },\n                    // 2.3.3.3.2\n                    function( r )\n                    {\n                        // 2.3.3.3.3\n                        if ( !called )\n                        {\n                            called = true;\n                            promise.set( REJECTED, r );\n                        }\n                    }\n                );\n            }\n            catch ( e )\n            {\n                // 2.3.3.3.4\n                if ( !called )\n                    promise.set( REJECTED, e );\n            }\n            return true;\n        }\n    }\n}\n\nvar Promise = type().def(\n{\n    ctor: function()\n    {\n        var self = this;\n        this.queue = [];\n        this.state = PENDING;\n        this.result = null;\n    },\n\n    value: function()\n    {\n        if ( this.state === REJECTED )\n            throw this.result;\n        else if ( this.state === PENDING )\n            throw new errors.InvalidOperationError( \"Promise is still in pending state.\" );\n        return this.result;\n    },\n\n    /**\n     * @description\n     * Satisfies 2.2 of the Promise/A+ spec.\n     * @param {function()} [onFulfilled]\n     * @param {function()} [onRejected]\n     * @param {boolean} [async]\n     * @return {Promise}\n     */\n    then: function( onFulfilled, onRejected, async )\n    {\n        var promise = this._pry( new Promise() );\n        async = async === false ? false : true;\n        this.enqueue( this.handle( promise, onFulfilled, onRejected ), async );\n        return promise._pub;\n    },\n\n    done: function( callback, async )\n    {\n        this.then( callback, null, async );\n        return this._pub;\n    },\n\n    fail: function( callback, async )\n    {\n        this.then( null, callback, async );\n        return this._pub;\n    },\n\n    always: function( callback, async )\n    {\n        this.then( callback, callback, async );\n        return this._pub;\n    },\n\n    _set: function( state, result )\n    {\n        if ( this.state === PENDING )\n        {\n            this.state = state;\n            this.result = result;\n            var i = 0, len = this.queue.length;\n            for ( ; i < len; i++ )\n                this.queue[ i ]( state, result );\n            this.queue = [];\n        }\n    },\n\n    __enqueue: function( handler, async )\n    {\n        if ( async )\n        {\n            var _handler = handler;\n            handler = function()\n            {\n                var args = arguments;\n                var run = function() {\n                    _handler.apply( undefined, args );\n                };\n                process.nextTick( run );\n            };\n        }\n        if ( this.state === PENDING )\n            this.queue.push( handler );\n        else\n            handler( this.state, this.result );\n    },\n\n    __handle: function( promise, onFulfilled, onRejected )\n    {\n        return function( state, result )\n        {\n            var callback = state === FULFILLED ? onFulfilled : onRejected, x;\n            // 2.2.7.3\n            // 2.2.7.4\n            if ( !util.isFunc( callback ) )\n            {\n                promise.set( state, result );\n                return;\n            }\n            try\n            {\n                // 2.2.5\n                x = callback.call( undefined, result );\n            }\n            catch ( e )\n            {\n                // 2.2.7.2\n                promise.set( REJECTED, e );\n                return;\n            }\n            // 2.2.7.1\n            if ( !resolve( promise, x ) )\n            {\n                // 2.3.4\n                promise.set( FULFILLED, x );\n            }\n        };\n    }\n});\n\nvar Deferred = module.exports = type().extend( Promise ).def(\n{\n    ctor: function()\n    {\n        var self = this;\n        this.promise =\n        {\n            then: function() {\n                return self.then.apply( self, arguments );\n            },\n            done: function()\n            {\n                self.done.apply( self, arguments );\n                return self.promise;\n            },\n            fail: function()\n            {\n                self.fail.apply( self, arguments );\n                return self.promise;\n            },\n            always: function()\n            {\n                self.always.apply( self, arguments );\n                return self.promise;\n            },\n            value: function() {\n                return self.value();\n            }\n        };\n    },\n\n    promise: { get: null, __set: null },\n\n    resolve: function( result )\n    {\n        this.set( FULFILLED, result );\n        return this._pub;\n    },\n\n    reject: function( reason )\n    {\n        this.set( REJECTED, reason );\n        return this._pub;\n    }\n});\n\nDeferred.when = function( promises )\n{\n    var deferred = new Deferred();\n    var tasks = util.isArray( promises ) ? promises : util.makeArray( arguments );\n    var progress = 0;\n    var results = [];\n    util.each( tasks, function( task, index )\n    {\n        task\n            .then( function( value )\n            {\n                results[ index ] = value;\n                if ( ++progress === tasks.length )\n                    deferred.resolve( results );\n            }, function( reason )\n            {\n                deferred.reject( reason );\n            }, false );\n    });\n    if ( !tasks.length )\n        deferred.resolve( [] );\n    return deferred.promise;\n};\n","var access = require( \"./access\" );\nvar build = require( \"./build\" );\nvar environment = require( \"./environment\" );\nvar errors = require( \"./errors\" );\nvar inits = require( \"./inits\" );\nvar special = require( \"./special\" );\nvar tunnel = require( \"./tunnel\" );\nvar util = require( \"./util\" );\n\nmodule.exports = create;\n\nvar GET_ACCESS = {\n    \"__\": access.PRIVATE,\n    \"_\": access.PROTECTED\n};\n\nvar IS_VIRTUAL = {\n    \"$\": true,\n    \"_$\": true\n};\n\nvar GET_PREFIX = {\n    \"__\": 2,\n    \"_$\": 2,\n    \"_\" : 1,\n    \"$\" : 1\n};\n\nvar ACCESS = {};\nACCESS[ access.PUBLIC ] = 1;\nACCESS[ access.PROTECTED ] = 2;\nACCESS[ access.PRIVATE ] = 3;\n\n/**\n * A regex for testing the use of _super inside a function.\n *\n * Simple JavaScript Inheritance\n * By John Resig http://ejohn.org/\n * MIT Licensed.\n */\nvar fnTest = /xyz/.test( function() { xyz = 0; } ) ? /\\b_super\\b/ : /.*/;\n\nvar typeCheckResult = false;\n\n/**\n * @description Defines a new type.\n * @return {Type}\n *\n * Inspired by John Resig's \"Simple JavaScript Inheritance\" class.\n */\nfunction create()\n{\n    var Scope = null;\n    var run = true;\n    var ctorDefined = false;\n\n    /**\n     * @interface\n     */\n    var Type = function()\n    {\n        if ( inits.has( inits.TYPE_CHECK ) )\n        {\n            typeCheckResult = true;\n            return;\n        }\n        if ( inits.has( inits.SCOPE ) )\n        {\n            if ( Scope === null )\n                Scope = defineScope( Type );\n            var scope =\n            {\n                parent: null,\n                self: null,\n                mixins: []\n            };\n            if ( environment.IE8 )\n            {\n                scope.self = getPlainDOMObject();\n                applyPrototypeMembers( Scope, scope.self );\n            }\n            else\n                scope.self = new Scope();\n            return scope;\n        }\n        if ( inits.has( inits.PUB ) && run )\n        {\n            var pub;\n            run = false;\n            if ( environment.IE8 )\n            {\n                pub = getPlainDOMObject();\n                applyPrototypeMembers( Type, pub );\n            }\n            else\n                pub = new Type();\n            build( Type, pub, arguments, true );\n            run = true;\n            return pub;\n        }\n    };\n\n    Type.members = {};\n    Type.parent = null;\n    Type.mixins = [];\n    \n    /**\n     * @description Sets the base type.\n     * @param {Type|function} Base\n     * @return {Type}\n     */\n    Type.extend = function( Base )\n    {\n        // Since name collision detection happens when the type is defined, we must prevent people\n        // from changing the inheritance hierarchy after defining members.\n        if ( util.keys( Type.members ).length > 0 )\n            throw new errors.DefinitionError( \"Cannot change the base type after members have been defined.\" );\n\n        if ( !util.isFunc( Base ) )\n            throw new TypeError( \"Base type must be a function.\" );\n\n        // Only set the parent member if the base type was created by us.\n        if ( isTypeOurs( Base ) )\n        {\n            // Check for circular reference.\n            var t = Base;\n            while ( t )\n            {\n                if ( t === Type )\n                    throw new errors.DefinitionError( \"Cannot inherit from \" + ( Base === Type ? \"self\" : \"derived type\" ) + \".\" );\n                t = t.parent;\n            }\n\n            Type.parent = Base;\n        }\n\n        inits.off( inits.PUB );\n        Type.prototype = new Base();\n        inits.on( inits.PUB );\n\n        return Type;\n    };\n\n    /**\n     * @description\n     * Defines members on the type.\n     *\n     * Example: The following defines a public method `foo`, a private method `bar`, and a public\n     * virtual method `baz` on the type `MyType`.\n     *\n        <pre>\n          var MyType = type().def({\n            foo: function() { },\n            __bar: function() { },\n            $baz: function() { }\n          });\n        </pre>\n     *\n     * @param {hash} members\n     * @return {Type}\n     */\n    Type.def = function( members )\n    {\n        util.each( members, function( member, name )\n        {\n            var info = parseMember( name );\n            name = info.name;\n\n            validateMember( Type, info );\n\n            if ( name === special.CTOR )\n            {\n                if ( util.isArray( member ) )\n                {\n                    Type.$inject = member;\n                    member = member.pop();\n                }\n                if ( !util.isFunc( member ) )\n                    throw new TypeError( \"Constructor must be a function.\" );\n            }\n\n            Type.members[ name ] =\n            {\n                access: info.access,\n                isVirtual: info.isVirtual\n            };\n\n            if ( util.isFunc( member ) )\n                defineMethod( Type, name, member );\n            else\n                defineProperty( Type, info, member );\n\n            if ( name === special.CTOR )\n            {\n                if (\n                    !Type.members.ctor.callsuper &&\n                    Type.parent !== null &&\n                    Type.parent.members.ctor &&\n                    Type.parent.members.ctor.params.length > 0\n                )\n                    throw new errors.DefinitionError( \"Constructor must call the base constructor explicitly because it contains parameters.\" );\n                ctorDefined = true;\n            }\n        });\n\n        return Type;\n    };\n\n    /**\n     * @description Defines events on the type.\n     * @param {Array} events\n     * @return {Type}\n     */\n    Type.events = function( events )\n    {\n        util.each( events, function( name )\n        {\n            var info = parseMember( name );\n            name = info.name;\n\n            validateMember( Type, info );\n\n            if ( name === special.CTOR )\n                throw new errors.DefinitionError( \"Event cannot be named 'ctor'.\" );\n\n            if ( info.isVirtual )\n                throw new errors.DefinitionError( \"Events cannot be virtual.\" );\n\n            Type.members[ name ] = {\n                access: info.access,\n                isEvent: true\n            };\n        });\n        return Type;\n    };\n\n    /**\n     * @descriptions Mixes other types in with the type.\n     * @param {Array} types\n     * @return {Type}\n     */\n    Type.include = function( types )\n    {\n        if ( ctorDefined )\n            throw new errors.DefinitionError( \"Mixins must be defined before the constructor.\" );\n\n        util.each( types, function( mixin )\n        {\n            if ( !isTypeOurs( mixin ) )\n                throw new TypeError( \"Mixin must be a type.\" );\n\n            if ( mixin === Type )\n                throw new errors.DefinitionError( \"Cannot include self.\" );\n\n            checkMixinForCircularReference( Type, mixin );\n            Type.mixins.push( mixin );\n        });\n        return Type;\n    };\n\n    return Type;\n}\n\n/**\n * @private\n * @description Checks mixin for circular references.\n * @param {Type} type\n * @param {Type} mixin\n */\nfunction checkMixinForCircularReference( type, mixin )\n{\n    if ( type === mixin )\n        throw new errors.DefinitionError( \"Cannot include type that includes self.\" );\n    util.each( mixin.mixins, function( m ) {\n        checkMixinForCircularReference( type, m );\n    });\n}\n\n/**\n * @private\n * @description Determines whether the type was created by us.\n * @param {function()} type\n * @return {boolean}\n */\nfunction isTypeOurs( type )\n{\n    inits.on( inits.TYPE_CHECK );\n    typeCheckResult = false;\n    type();\n    inits.off( inits.TYPE_CHECK );\n    return typeCheckResult;\n}\n\n/**\n * @private\n * @description Creates a new private scope type.\n * @param {Type} Type\n * @return {Scope}\n */\nfunction defineScope( Type )\n{\n    var Scope = function() {};\n    inits.off( inits.PUB | inits.SCOPE );\n    Scope.prototype = new Type();\n    inits.on( inits.PUB | inits.SCOPE );\n\n    var fn = Scope.prototype;\n\n    /**\n     * Gets the private scope of the type instance.\n     */\n    fn._pry = function( pub )\n    {\n        tunnel.open( Type );\n        var scope = !!pub && !!pub.$scope && util.isFunc( pub.$scope ) ? pub.$scope() : null;\n        tunnel.close();\n        return scope || pub;\n    };\n\n    return Scope;\n}\n\n/**\n * @description Gets the member info by parsing the member name.\n * @param {string} name\n * @return {Object}\n */\nfunction parseMember( name )\n{        \n    var twoLetter = name.substr( 0, 2 );\n\n    // determines the member's visibility (public|private)\n    var modifier = GET_ACCESS[ twoLetter ] || GET_ACCESS[ name[0] ] || access.PUBLIC;\n\n    // determines whether the method can be overridden\n    var isVirtual = IS_VIRTUAL[ twoLetter ] || IS_VIRTUAL[ name[0] ] || false;\n\n    // trim away the modifiers\n    name = name.substr( GET_PREFIX[ twoLetter ] || GET_PREFIX[ name[0] ] || 0 );\n\n    // \"ctor\" is a special name for the constructor method\n    if ( name === special.CTOR )\n    {\n        modifier = access.PRIVATE;\n        isVirtual = false;\n    }\n\n    return {\n        access: modifier,\n        isVirtual: isVirtual,\n        name: name\n    };\n}\n\n/**\n * @description Checks the memeber info on a type and throws an error if invalid.\n * @param {Type} type\n * @param {Object} info\n */\nfunction validateMember( type, info )\n{\n    // check for name collision\n    if ( isMemberDefined( type, info.name ) )\n        throw new errors.DefinitionError( \"Member '\" + info.name + \"' is already defined.\" );\n\n    // make sure the access modifier isn't being changed\n    if (\n        info.access !== access.PRIVATE &&\n        type.parent !== null &&\n        type.parent.members[ info.name ] &&\n        type.parent.members[ info.name ].access !== info.access\n    )\n    {\n        throw new errors.DefinitionError( \"Cannot change access modifier of member '\" + name + \"' from \" +\n            type.parent.members[ info.name ].access + \" to \" + info.access + \".\" );\n    }\n}\n\n/**\n * @private\n * @description Checks if member name collides with another member.\n * @param {Type} type The type to check.\n * @param {string} name The member name.\n * @param {bool} [parent] True if the type being checked is a base type.\n * @return {bool}\n */\nfunction isMemberDefined( type, name, parent )\n{\n    if (\n        type.members[ name ] &&\n        ( !parent || type.members[ name ].access !== access.PRIVATE ) &&\n        ( !parent || !type.members[ name ].isVirtual )\n    )\n        return true;\n    if ( type.parent !== null )\n        return isMemberDefined( type.parent, name, true );\n    return false;\n}\n\n/**\n * @private\n * @description Defines a method on the type.\n * @param {Type} type\n * @param {string} name\n * @param {function()} method\n */\nfunction defineMethod( type, name, method )\n{\n    var params = [];\n    var match = method.toString().match( /^function\\s*\\(([^())]+)\\)/ );\n    if ( match !== null )\n    {\n        util.each( match[1].split( \",\" ), function( param, index ) {\n            params.push( util.trim( param ) );\n        });\n    }\n    type.members[ name ].method = method;\n    type.members[ name ].params = params;\n    type.members[ name ].callsuper = fnTest.test( method );\n}\n\n/**\n * @private\n * @description Defines a property on the type.\n * @param {Type} Type\n * @param {string} name\n * @param {Object} property\n */\nfunction defineProperty( Type, info, property )\n{\n    if ( util.typeOf( property ) !== \"object\" )\n        property = { value: property };\n\n    var different = 0;\n\n    // IE8 will actually enumerate over members added during an enumeration,\n    // so we need to write to a temp object and copy the accessors over once\n    // we're done.\n    var temp = {};\n    util.each( property, function( method, type )\n    {\n        type = type.toLowerCase();\n        var twoLetter = type.substr( 0, 2 );\n        if ( IS_VIRTUAL[ twoLetter ] || IS_VIRTUAL[ type[0] ] )\n            throw new errors.DefinitionError( \"Property '\" + info.name + \"' cannot have virtual accessors.\" );\n\n        var access = GET_ACCESS[ twoLetter ] || GET_ACCESS[ type[0] ] || info.access;\n        if ( ACCESS[ access ] < ACCESS[ info.access ] )\n        {\n            throw new errors.DefinitionError( \"The \" + type + \" accessor of the property '\" + info.name +\n                \"' cannot have a lower access modifier than the property itself.\" );\n        }\n\n        type = type.substr( GET_PREFIX[ twoLetter ] || GET_PREFIX[ type[0] ] || 0 );\n\n        if ( type !== \"get\" && type !== \"set\" )\n            return;\n\n        if ( access !== info.access )\n            different++;\n\n        if (\n            Type.parent !== null &&\n            Type.parent.members[ info.name ] &&\n            Type.parent.members[ info.name ][ type ] &&\n            Type.parent.members[ info.name ][ type ].access !== access\n        )\n        {\n            throw new errors.DefinitionError( \"Cannot change access modifier of '\" + type + \"' accessor for property '\" + info.name +\n                \"' from \" + Type.parent.members[ info.name ][ type ].access + \" to \" + access + \".\" );\n        }\n\n        if ( method !== null && !util.isFunc( method ) )\n        {\n            throw new TypeError( type.substr( 0, 1 ).toUpperCase() + type.substr( 1 ) + \" accessor for property '\" +\n                info.name + \"' must be a function or null (uses default implementation.)\" );\n        }\n        \n        temp[ type ] =\n        {\n            access: access,\n            method: method\n        };\n    });\n    property.get = temp.get;\n    property.set = temp.set;\n\n    if ( different === 2 )\n        throw new errors.DefinitionError( \"Cannot set access modifers for both accessors of the property '\" + info.name + \"'.\" );\n\n    if ( !property.get && !property.set )\n    {\n        property.get = { access: info.access };\n        property.set = { access: info.access };\n    }\n\n    if ( property.get && !util.isFunc( property.get.method ) )\n    {\n        property.get.method = function() {\n            return this._value();\n        };\n    }\n    if ( property.set && !util.isFunc( property.set.method ) )\n    {\n        property.set.method = function( value ) {\n            this._value( value );\n        };\n    }\n\n    util.each([ property.get, property.set ], function( accessor, index )\n    {\n        if ( !accessor ) return;\n\n        var type = index === 0 ? \"get\" : \"set\";\n        if (\n            Type.parent !== null &&\n            Type.parent.members[ info.name ] &&\n            Type.parent.members[ info.name ].access !== access.PRIVATE &&\n            Type.parent.members[ info.name ][ type ] === undefined\n        )\n            throw new errors.DefinitionError( \"Cannot change read/write definition of property '\" + info.name + \"'.\" );\n\n        Type.members[ info.name ][ type ] =\n        {\n            access: accessor.access,\n            method: accessor.method,\n            callsuper: fnTest.test( accessor.method )\n        };\n    });\n\n    Type.members[ info.name ].value = property.value ? property.value : null;\n}\n\n/**\n * @private\n * @param {Type} type\n * @param {Object} obj\n */\nfunction applyPrototypeMembers( type, obj )\n{\n    var proto = type.prototype;\n    if ( proto.constructor.prototype !== proto )\n        applyPrototypeMembers( proto.constructor, obj );\n    for ( var prop in proto )\n    {\n        if ( util.hasOwn( proto, prop ) )\n            obj[ prop ] = proto[ prop ];\n    }\n}\n\nfunction getPlainDOMObject()\n{\n    function overwrite( obj, prop )\n    {\n        var _value;\n        Object.defineProperty( obj, prop,\n        {\n            configurable: true,\n            get: function() {\n                return _value;\n            },\n            set: function( value ) {\n                _value = value;\n            }\n        });\n    }\n    var obj = document.createElement(), prop;\n    for ( prop in obj )\n    {\n        if ( util.hasOwn( obj, prop ) )\n            overwrite( obj, prop );\n    }\n    return obj;\n}\n","// IE8 only supports Object.defineProperty on DOM objects.\n// http://msdn.microsoft.com/en-us/library/dd548687(VS.85).aspx\n// http://stackoverflow.com/a/4867755/740996\nvar IE8 = false;\ntry {\n    Object.defineProperty( {}, \"x\", {} );\n} catch ( e ) {\n    IE8 = true;\n}\n\nmodule.exports = {\n    IE8: IE8,\n    window: typeof window === \"object\" ? window : {}\n};\n","var DefinitionError = function( message ) {\n    this.message = message;\n};\nDefinitionError.prototype = new Error();\nDefinitionError.prototype.name = \"type.DefinitionError\";\n\nvar InitializationError = function( message ) {\n    this.message = message;\n};\nInitializationError.prototype = new Error();\nInitializationError.prototype.name = \"type.InitializationError\";\n\nvar AccessViolationError = function( message ) {\n    this.message = message;\n};\nAccessViolationError.prototype = new Error();\nAccessViolationError.prototype.name = \"type.AccessViolationError\";\n\nvar InvalidOperationError = function( message ) {\n    this.message = message;\n};\nInvalidOperationError.prototype = new Error();\nInvalidOperationError.prototype.name = \"type.InvalidOperationError\";\n\nvar ArgumentError = function( message ) {\n    this.message = message;\n};\nArgumentError.prototype = new Error();\nArgumentError.prototype.name = \"type.ArgumentError\";\n\nmodule.exports =\n{\n    DefinitionError: DefinitionError,\n    InitializationError: InitializationError,\n    AccessViolationError: AccessViolationError,\n    InvalidOperationError: InvalidOperationError,\n    ArgumentError: ArgumentError\n};\n","// A global flag to control execution of type initializers.\nvar PUB = 1;\nvar SCOPE = 2;\nvar TYPE_CHECK = 4;\nvar inits = PUB;\n\nmodule.exports =\n{\n    PUB: PUB,\n    SCOPE: SCOPE,\n    TYPE_CHECK: TYPE_CHECK,\n    on: function( flag ) {\n        inits |= flag;\n    },\n    off: function( flag ) {\n        inits &= ~flag;\n    },\n    has: function( flag ) {\n        return ( inits & flag ) === flag;\n    }\n};\n","var environment = require( \"./environment\" );\nvar errors = require( \"./errors\" );\nvar type = require( \"./define\" );\nvar util = require( \"./util\" );\n\nvar Deferred = require( \"./deferred\" );\n\nvar PROVIDER = \"Provider`\";\nvar LAZY_PROVIDER = \"LazyProvider`\";\n\nvar Injector = module.exports = type().def(\n{\n    ctor: function() {\n        this.container = {};\n    },\n\n    /**\n     * @description Registers a service.\n     * @param {string} service\n     * @return {BindingSelector}\n     */\n    bind: function( service )\n    {\n        var self = this;\n        if ( !service || !util.isString( service ) )\n            throw new errors.ArgumentError( \"Argument 'service' must have a value.\" );\n        return {\n            /**\n             * @description Specifies which provider to bind the service to.\n             * @param {Array|function()} provider\n             * @return {BindingConfigurator}\n             */\n            to: function( provider )\n            {\n                var binding = self.register( service, provider );\n                var config =\n                {\n                    /**\n                     * @description\n                     * Causes the binding to return the same instance for all instances resolved through\n                     * the injector.\n                     * @return {BindingConfigurator}\n                     */\n                    asSingleton: function()\n                    {\n                        var _resolve = binding.resolve;\n                        var resolved = false;\n                        var result;\n                        binding.resolve = function()\n                        {\n                            if ( !resolved )\n                            {\n                                result = _resolve.apply( undefined, arguments );\n                                resolved = true;\n                            }\n                            return result;\n                        };\n                        return config;\n                    },\n\n                    /**\n                     * @description\n                     * Adds a constraint to the binding so that it is only used when the bound\n                     * service is injected into one of the specified services.\n                     * @param {string[]} services\n                     * @return {BindingConfigurator}\n                     */\n                    whenFor: function( services )\n                    {\n                        if ( util.isArray( services ) && services.length )\n                            binding.filter = services.slice( 0 );\n                        else\n                            throw new errors.ArgumentError( \"Expected 'services' to be an array of string.\" );\n                        return config;\n                    }\n                };\n                return config;\n            }\n        };\n    },\n\n    /**\n     * @description Unregisters a service.\n     * @param {string} service\n     * @param {string[]} [filter]\n     * @return {Injector}\n     */\n    unbind: function( service, filter )\n    {\n        filter = filter || [];\n        var bindings = this.container[ service ] || [];\n        var flen = filter.length;\n        if ( flen )\n        {\n            var b = 0, blen = bindings.length, f, i;\n            for ( ; b < blen; b++ )\n            {\n                if ( bindings[ b ].filter )\n                {\n                    // Remove each service in the filter parameter from the binding's filter list.\n                    f = 0;\n                    for ( ; f < flen; f++ )\n                    {\n                        // Account for sloppy programming and remove all occurences of the service.\n                        i = util.indexOf( bindings[ b ].filter, filter[ f ] );\n                        while ( i > -1 )\n                        {\n                            bindings[ b ].filter.splice( i, 1 );\n                            i = util.indexOf( bindings[ b ].filter, filter[ f ] );\n                        }\n                    }\n                }\n                if ( !bindings[ b ].filter.length )\n                {\n                    // If the binding now has an empty filter list, remove it because it is useless.\n                    // Note: Move the cursor (b) back one slot so that we don't skip the next item.\n                    bindings.splice( b, 1 );\n                    b--;\n                }\n            }\n            if ( !bindings.length )\n                delete this.container[ service ];\n        }\n        else\n            delete this.container[ service ];\n        return this._pub;\n    },\n\n    /**\n     * @description Resolves a target and its dependencies.\n     * @param {string|function()|Array} target\n     * @param {...Object} [args]\n     * @return {Deferred.<TService>}\n     */\n    resolve: function( target, args )\n    {\n        var self = this;\n        var deferred = new Deferred();\n        args = util.makeArray( arguments );\n        args.shift( 0 );\n        this.resolveTarget( target )\n            .then( function( recipe )\n            {\n                var factory = self.makeFactory( recipe );\n                if ( recipe.theory.isProvider )\n                    deferred.resolve( factory );\n                else\n                    deferred.resolve( factory.apply( undefined, args ) );\n\n            }, function( reason )\n            {\n                deferred.reject( reason );\n            }, false );\n        return deferred.promise;\n    },\n\n    /**\n     * @description\n     * Binds an object graph.\n     * For example:\n     *   <pre>\n     *     .autoBind({\n     *       foo: {\n     *         bar: 2\n     *       }\n     *     });\n     *   </pre>\n     * is equivalent to:\n     *   <pre>\n     *     .bind( \"foo.bar\" ).to( 2 );\n     *   </pre>\n     * @param {Object} graph\n     * @return {Injector}\n     */\n    autoBind: function( graph )\n    {\n        this.registerGraph( \"\", graph );\n        return this._pub;\n    },\n\n    /**\n     * @private\n     * @description Binds a service to a provider and returns the binding.\n     * @param {string} service\n     * @param {Array|function()} provider\n     * @return {Binding}\n     */\n    __register: function( service, provider )\n    {\n        var binding = null;\n        if ( util.isArray( provider ) )\n        {\n            provider = provider.slice( 0 );\n            binding = {\n                resolve: provider.pop(),\n                inject: provider\n            };\n        }\n        else\n        {\n            binding = {\n                resolve: provider,\n                inject: ( provider.$inject || [] ).slice( 0 )\n            };\n        }\n        if ( !util.isFunc( binding.resolve ) )\n        {\n            var value = binding.resolve;\n            binding.resolve = function() {\n                return value;\n            };\n        }\n        this.container[ service ] = this.container[ service ] || [];\n        this.container[ service ].push( binding );\n        return binding;\n    },\n\n    /**\n     * @private\n     * @param {string} path\n     * @param {Object} graph\n     */\n    __registerGraph: function( path, graph )\n    {\n        var self = this,\n            prefix = path === \"\" ?  \"\" : path + \".\";\n        util.each( graph, function( type, name )\n        {\n            if ( util.isPlainObject( type ) )\n                self.registerGraph( prefix + name, type );\n            else\n                self.register( prefix + name, type );\n        });\n    },\n\n    /**\n     * @param {Recipe} recipe\n     * @return {function()}\n     */\n    __makeFactory: function( recipe )\n    {\n        if ( recipe.theory.isLazy )\n            return this.makeLazyFactory( recipe );\n\n        /**\n         * @param {Recipe} recipe\n         * @return {Component}\n         */\n        function toComponent( recipe )\n        {\n            return {\n                parent: null,\n                position: null,\n                cache: [],\n                recipe: recipe\n            };\n        }\n\n        var self = this;\n        var generations = [];\n        var root = toComponent( recipe );\n        var current = [ root ];\n        var next;\n\n        while ( current.length )\n        {\n            next = [];\n            util.each( current, function( component )\n            {\n                if ( component.recipe.theory.isLazy )\n                    return;\n\n                util.each( component.recipe.dependencies, function( recipe, position )\n                {\n                    var dependency = toComponent( recipe );\n                    dependency.parent = component;\n                    dependency.position = position;\n                    next.push( dependency );\n                });\n            });\n            generations.push( current );\n            current = next;\n        }\n\n        generations.reverse();\n        generations.pop();\n\n        return function()\n        {\n            util.each( generations, function( generation )\n            {\n                util.each( generation, function( component )\n                {\n                    component.parent.cache[ component.position ] =\n                        component.recipe.theory.isProvider ?\n                        self.makeFactory( component.recipe ) :\n                        component.recipe.theory.resolve.apply( undefined, component.cache );\n                    component.cache = [];\n                });\n            });\n            var args = root.cache.concat( util.makeArray( arguments ) );\n            root.cache = [];\n            return root.recipe.theory.resolve.apply( undefined, args );\n        };\n    },\n\n    /**\n     * @param {Recipe} recipe\n     * @return {function()}\n     */\n    __makeLazyFactory: function( recipe )\n    {\n        var self = this;\n        var factory = null;\n        return function()\n        {\n            var deferred = new Deferred();\n            var args = arguments;\n            if ( !factory )\n            {\n                self.resolveTarget( recipe.theory.name )\n                    .then( function( recipe )\n                    {\n                        factory = self.makeFactory( recipe );\n                        deferred.resolve( factory.apply( undefined, args ) );\n                    }, function( reason )\n                    {\n                        deferred.reject( reason );\n                    }, false );\n            }\n            else\n                deferred.resolve( factory.apply( undefined, args ) );\n            return deferred.promise;\n        };\n    },\n\n    /**\n     * @description Attempts to resolve a target.\n     * @param {string|Array|function()} target\n     * @return {Deferred.<Recipe>}\n     */\n    __resolveTarget: function( target )\n    {\n        function load()\n        {\n            modules = util.map( plan.missing, function( service )\n            {\n                if ( service !== PROVIDER && new RegExp( \"^\" + PROVIDER ).test( service ) )\n                    service = service.substr( PROVIDER.length );\n                else if ( service !== LAZY_PROVIDER && new RegExp( \"^\" + LAZY_PROVIDER ).test( service ) )\n                    service = service.substr( LAZY_PROVIDER.length );\n                return service.replace( /\\./g, \"/\" );\n            });\n            environment.window.require( modules, done, fail );\n        }\n\n        function done()\n        {\n            var bindings = {};\n            var args = arguments;\n\n            util.each( plan.missing, function( service, index )\n            {\n                // Validate the returned service. If there's no way we can turn it into a binding,\n                // we'll get ourselves into a neverending loop trying to resolve it.\n                var svc = args[ index ];\n\n                if ( !svc || !( /(string|function|array)/ ).test( util.typeOf( svc ) ) )\n                {\n                    deferred.reject(\n                        new TypeError( \"Module '\" + modules[ index ] + \"' loaded successfully. Failed to resolve service '\" +\n                            service + \"'. Expected service to be a string, array, or function. Found '\" +\n                            ( svc && svc.toString ? svc.toString() : util.typeOf( svc ) ) + \"' instead.\"\n                        )\n                    );\n                    return false;\n                }\n                if ( util.isArray( svc ) && !util.isFunc( svc[ svc.length - 1 ] ) )\n                {\n                    svc = svc[ svc.length - 1 ];\n                    deferred.reject(\n                        new TypeError( \"Module '\" + modules[ index ] + \"' loaded successfully. Failed to resolve service '\" +\n                            service + \"'. Found array. Expected last element to be a function. Found '\" +\n                            ( svc && svc.toString ? svc.toString() : util.typeOf( svc ) ) + \"' instead.\"\n                        )\n                    );\n                    return false;\n                }\n\n                bindings[ service ] = args[ index ];\n            });\n\n            if ( deferred.state === \"rejected\" )\n                return;\n\n            plan.update( bindings );\n\n            if ( plan.missing.length )\n                load();\n            else\n                deferred.resolve( plan.recipe );\n        }\n\n        function fail( reason ) {\n            deferred.reject( reason );\n        }\n\n        var deferred = new Deferred();\n        var modules;\n        var plan = this.getExecutionPlan( target );\n\n        if ( plan.missing.length )\n        {\n            if ( environment.window.require )\n                load();\n            else\n            {\n                deferred.reject( new errors.InvalidOperationError( \"Service(s) \" +\n                    util.map( plan.missing, function( x ) { return \"'\" + x + \"'\"; }).join( \", \" ) + \" have not been registered.\" ) );\n            }\n        }\n        else\n            deferred.resolve( plan.recipe );\n\n        return deferred.promise;\n    },\n\n    /**\n     * @private\n     * @description Creates an execution plan for resolving a target.\n     * @param {string|Array|function()} target\n     * @return {Plan}\n     */\n    __getExecutionPlan: function( target )\n    {\n        /**\n         * @param {string} service\n         * @param {function( Recipe )} callback\n         */\n        function watchFor( service, callback )\n        {\n            var isLazy = service !== LAZY_PROVIDER && new RegExp( \"^\" + LAZY_PROVIDER ).test( service );\n            var isProvider = isLazy || service !== PROVIDER && new RegExp( \"^\" + PROVIDER ).test( service );\n            var handler = function( bindings )\n            {\n                var svc = bindings[ service ];\n                if ( svc )\n                {\n                    var theory = self.theorize( svc );\n                    if ( theory )\n                    {\n                        theory.isProvider = isProvider;\n                        theory.isLazy = isLazy;\n                        callback( resolve( theory ) );\n                    }\n                    else\n                    {\n                        missing.push( svc );\n                        watchFor( svc, callback );\n                    }\n                    watches.splice( util.indexOf( watches, handler ), 1 );\n                }\n            };\n            watches.push( handler );\n        }\n\n        /**\n         * @param {Theory} theory\n         * @return {Recipe}\n         */\n        function toRecipe( theory )\n        {\n            return {\n                theory: theory,\n                dependencies: []\n            };\n        }\n\n        /**\n         * @description\n         * Turns a theory into something that can be resolved. A theory cannot be resolved unless\n         * all of its dependencies can also be resolved.\n         * @param {Theory} theory\n         * @return {Recipe}\n         */\n        function resolve( theory )\n        {\n            var recipe = toRecipe( theory );\n\n            // Optimization: short-circuits an extra function call.\n            if ( recipe.theory.isLazy )\n                return recipe;\n\n            var current = [ recipe ], next;\n            while ( current.length )\n            {\n                next = [];\n                util.each( current, function( recipe )\n                {\n                    if ( recipe.theory.isLazy )\n                        return;\n\n                    util.each( recipe.theory.inject, function( service, position )\n                    {\n                        var dependency = self.evaluate( service, recipe.theory.name );\n                        if ( dependency )\n                        {\n                            dependency = toRecipe( dependency );\n                            recipe.dependencies[ position ] = dependency;\n                            next.push( dependency );\n                        }\n                        else\n                        {\n                            missing.push( service );\n                            watchFor( service, function( dependency ) {\n                                recipe.dependencies[ position ] = dependency;\n                            });\n                        }\n                    });\n                });\n                current = next;\n            }\n            return recipe;\n        }\n\n        var self = this;\n        var missing = [];\n        var watches = [];\n        var theory = this.evaluate( target );\n        var recipe = null;\n\n        if ( theory )\n            recipe = resolve( theory );\n        else\n        {\n            // The only time .evaluate() would return null is if the target was a name (string)\n            // pointing to a service that hasn't been bound yet.\n            missing.push( target );\n            watchFor( target, function( recipe ) {\n                plan.recipe = recipe;\n            });\n        }\n\n        var plan =\n        {\n            recipe: recipe,\n            missing: missing,\n            update: function( bindings )\n            {\n                missing.splice( 0 );\n                util.each( watches.slice( 0 ), function( handler ) {\n                    handler( bindings );\n                });\n            }\n        };\n        return plan;\n    },\n\n    /**\n     * @private\n     * @description Converts an anonymous target to a theory.\n     * @param {Array|function()} target\n     * @return {Theory}\n     */\n    __theorize: function( target )\n    {\n        if ( !target )\n            return null;\n        var result = null;\n        if ( util.isFunc( target ) )\n        {\n            result = {\n                resolve: target,\n                inject: ( target.$inject || [] ).slice( 0 )\n            };\n        }\n        else if ( util.isArray( target ) )\n        {\n            target = target.slice( 0 );\n            result = {\n                resolve: target.pop(),\n                inject: target\n            };\n        }\n        return result;\n    },\n\n    /**\n     * @private\n     * @description Analyzes a target (named or anonymous) and returns a theory on how to resolve it.\n     * @param {string|Array|function()} target\n     * @return {Theory}\n     */\n    __evaluate: function( target, destination )\n    {\n        function find( service )\n        {\n            var bindings = self.container[ service ] || [];\n            var i = bindings.length - 1;\n            for ( ; i >= 0; i-- )\n            {\n                if ( !destination )\n                {\n                    if ( !bindings[ i ].filter )\n                        break;\n                }\n                else if ( !bindings[ i ].filter || util.indexOf( bindings[ i ].filter, destination ) > -1 )\n                    break;\n            }\n            return bindings[ i ] || null;\n        }\n\n        var self = this;\n        var result = this.theorize( target );\n        if ( !result && util.isString( target ) )\n        {\n            var binding = find( target );\n            if ( binding )\n            {\n                result = {\n                    resolve: binding.resolve,\n                    inject: binding.inject.slice( 0 ),\n                    name: target\n                };\n            }\n            if ( !result && target !== PROVIDER && new RegExp( \"^\" + PROVIDER ).test( target ) )\n            {\n                binding = find( target.substr( PROVIDER.length ) );\n                if ( binding )\n                {\n                    result = {\n                        resolve: binding.resolve,\n                        inject: binding.inject.slice( 0 ),\n                        name: target.substr( PROVIDER.length ),\n                        isProvider: true\n                    };\n                }\n            }\n            if ( !result && target !== LAZY_PROVIDER && new RegExp( \"^\" + LAZY_PROVIDER ).test( target ) )\n            {\n                binding = find( target.substr( LAZY_PROVIDER.length ) ) || {};\n                result = {\n                    resolve: binding.resolve || null,\n                    inject: binding.inject || null,\n                    name: target.substr( LAZY_PROVIDER.length ),\n                    isProvider: true,\n                    isLazy: true\n                };\n                if ( result.inject )\n                    result.inject = result.inject.slice( 0 );\n            }\n        }\n        return result;\n    }\n});\n\nmodule.exports.providerOf = function( service ) {\n    return PROVIDER + service;\n};\n\nmodule.exports.lazyProviderOf = function( service ) {\n    return LAZY_PROVIDER + service;\n};\n","module.exports = {\n    CTOR: \"ctor\"\n};\n","// When we want to pry an object open, we set this to the type of the object\n// and call $scope to extract the private scope.\nvar value = null;\n\nmodule.exports = {\n    open: function( type ) {\n        value = type;\n    },\n    close: function() {\n        value = null;\n    },\n    value: function() {\n        return value;\n    }\n};\n","var deferred = require( \"./deferred\" );\nvar define = require( \"./define\" );\nvar environment = require( \"./environment\" );\nvar errors = require( \"./errors\" );\nvar injector = require( \"./injector\" );\nvar util = require( \"./util\" );\n\nvar type = define;\ntype.of = util.typeOf;\n\ntype.DefinitionError = errors.DefinitionError;\ntype.InitializationError = errors.InitializationError;\ntype.AccessViolationError = errors.AccessViolationError;\ntype.InvalidOperationError = errors.InvalidOperationError;\ntype.ArgumentError = errors.ArgumentError;\n\ntype.injector = injector;\ntype.providerOf = injector.providerOf;\ntype.lazyProviderOf = injector.lazyProviderOf;\n\ntype.defer = deferred;\n\nmodule.exports = environment.window.type = type;\n","module.exports =\n{\n    makeArray: makeArray,\n    each: each,\n    typeOf: typeOf,\n    isFunc: isFunc,\n    isString: isString,\n    isArray: isArray,\n    trim: trim,\n    keys: keys,\n    hasOwn: hasOwn,\n    indexOf: indexOf,\n    isPlainObject: isPlainObject,\n    map: map\n};\n\n/**\n * @private\n * @description\n * Determines whether an object can be iterated over like an array.\n * https://github.com/jquery/jquery/blob/a5037cb9e3851b171b49f6d717fb40e59aa344c2/src/core.js#L501\n * @param {*} obj\n * @return {boolean}\n */\nfunction isArrayLike( obj )\n{\n    var length = obj.length,\n        type = typeOf( obj );\n\n    if ( typeOf( obj ) === \"window\" )\n        return false;\n\n    if ( obj.nodeType === 1 && length )\n        return true;\n\n    return (\n        type === \"array\" ||\n        type !== \"function\" && (\n            length === 0 ||\n            typeof length === \"number\" && length > 0 && ( length - 1 ) in obj\n        )\n    );\n}\n\n/**\n * @private\n * @description Turns an object into a true array.\n * @param {Object|Array} obj\n * @return {Array}\n */\nfunction makeArray( obj )\n{\n    if ( isArray( obj ) )\n        return obj;\n    var result = [];\n    each( obj, function( item ) {\n        result.push( item );\n    });\n    return result;\n}\n\n/**\n * @private\n * @description\n * Iterates of an array or object, passing in the item and index / key.\n * https://github.com/jquery/jquery/blob/a5037cb9e3851b171b49f6d717fb40e59aa344c2/src/core.js#L316\n * @param {Object|Array} obj\n * @param {function()} callback\n */\nfunction each( obj, callback )\n{\n    var i = 0, value;\n    if ( isArrayLike( obj ) )\n    {\n        for ( ; i < obj.length; i++ )\n        {\n            if ( callback.call( undefined, obj[ i ], i ) === false )\n                break;\n        }\n    }\n    else\n    {\n        for ( i in obj )\n        {\n            if ( hasOwn( obj, i ) && callback.call( undefined, obj[ i ], i ) === false )\n                break;\n        }\n    }\n}\n\n/**\n * @private\n * @description\n * Gets the internal JavaScript [[Class]] of an object.\n * http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/\n * @param {*} object\n * @return {string}\n */\nfunction typeOf( object )\n{\n    // In IE8, Object.toString on null and undefined returns \"object\".\n    if ( object === null )\n        return \"null\";\n    if ( object === undefined )\n        return \"undefined\";\n    return Object.prototype.toString.call( object )\n        .match( /^\\[object\\s(.*)\\]$/ )[1].toLowerCase();\n}\n\n/**\n * @private\n * @description Determines whether an object is a function.\n * @param {*} object\n * @return {boolean}\n */\nfunction isFunc( object ) {\n    return typeOf( object ) === \"function\";\n}\n\n/**\n * @private\n * @description Determines whether an object is an array.\n * @param {*} object\n * @return {boolean}\n */\nfunction isArray( object ) {\n    return typeOf( object ) === \"array\";\n}\n\nfunction isString( object ) {\n    return typeOf( object ) === \"string\";\n}\n\n/**\n * @private\n * @description\n * Removes trailing whitespace from a string.\n * http://stackoverflow.com/a/2308157/740996\n * @param {string} value\n * @return {string}\n */\nfunction trim( value ) {\n    return value.trim ? value.trim() : value.replace( /^\\s+|\\s+$/g, \"\" );\n}\n\n/**\n * @private\n * @description Gets the keys of an object.\n * @param {Object} object\n * @return {Array}\n */\nfunction keys( object )\n{\n    if ( Object.keys )\n        return Object.keys( object );\n    var ret = [];\n    for ( var key in object )\n    {\n        if ( hasOwn( object, key ) )\n            ret.push( key );\n    }\n    return ret;\n}\n\n/**\n * @private\n * @description Determines whether a property exists on the object itself (as opposed to being in the prototype.)\n * @param {Object} obj\n * @param {string} prop\n * @return {boolean}\n */\nfunction hasOwn( obj, prop ) {\n    return Object.prototype.hasOwnProperty.call( obj, prop );\n}\n\n/**\n * @private\n * @description\n * Searches an array for the specified item and returns its index. Returns -1 if the item is not found.\n * @param {Array} array\n * @param {*} item\n * @return {number}\n */\nfunction indexOf( array, item )\n{\n    if ( array.indexOf )\n        return array.indexOf( item );\n    else\n    {\n        var index = -1;\n        each( array, function( obj, i )\n        {\n            if ( obj === item )\n            {\n                index = i;\n                return false;\n            }\n        });\n        return index;\n    }\n}\n\n/**\n * @private\n * @description Determines whether an object was created using \"{}\" or \"new Object\".\n * https://github.com/jquery/jquery/blob/a5037cb9e3851b171b49f6d717fb40e59aa344c2/src/core.js#L237\n * @param {Object} obj\n * @return {boolean}\n */\nfunction isPlainObject( obj )\n{\n    // Not plain objects:\n    // - Any object or value whose internal [[Class]] property is not \"[object Object]\"\n    // - DOM nodes\n    // - window\n    if ( typeOf( obj ) !== \"object\" || obj.nodeType || typeOf( obj ) === \"window\" )\n        return false;\n\n    // Support: Firefox <20\n    // The try/catch suppresses exceptions thrown when attempting to access\n    // the \"constructor\" property of certain host objects, ie. |window.location|\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=814622\n    try\n    {\n        if (\n            obj.constructor &&\n            !hasOwn( obj.constructor.prototype, \"isPrototypeOf\" )\n        )\n            return false;\n    }\n    catch ( e ) {\n        return false;\n    }\n\n    // If the function hasn't returned already, we're confident that\n    // |obj| is a plain object, created by {} or constructed with new Object\n    return true;\n}\n\nfunction map( items, callback, context )\n{\n    items = makeArray( items );\n    if ( Array.prototype.map )\n        return items.map( callback, context );\n    else\n    {\n        var result = [];\n        each( items, function( item, index ) {\n            result.push( callback.call( context, item, index ) );\n        });\n    }\n}\n"]}